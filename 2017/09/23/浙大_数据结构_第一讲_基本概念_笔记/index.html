<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="a beginner's blog"><title>浙大_数据结构_第一讲_基本概念_笔记 | Sixtar</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浙大_数据结构_第一讲_基本概念_笔记</h1><a id="logo" href="/.">Sixtar</a><p class="description">不忘初心! Stay hungry,Stay foolish.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/x/"><i class="fa fa-plane"> x</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浙大_数据结构_第一讲_基本概念_笔记</h1><div class="post-meta">Sep 23, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-什么是数据结构"><span class="toc-number">1.</span> <span class="toc-text">1.1 什么是数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-图书存放方式的例子说明"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.1 图书存放方式的例子说明:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-关于空间的使用"><span class="toc-number">1.2.</span> <span class="toc-text">1.1.2 关于空间的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#结果-N取大值时递归由于占用过多资源直接报错-所以要谨慎使用递归"><span class="toc-number">1.2.1.</span> <span class="toc-text">结果: N取大值时递归由于占用过多资源直接报错.所以要谨慎使用递归.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结果-第一种不如第二种先采用结合律有内往外算的方法"><span class="toc-number">1.2.2.</span> <span class="toc-text">结果: 第一种不如第二种先采用结合律有内往外算的方法.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tips-C语言clock-函数计算运行时钟打点示例"><span class="toc-number">1.2.3.</span> <span class="toc-text">Tips: C语言clock()函数计算运行时钟打点示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结论-解决问题方法的效率还跟算法的巧妙程度有关"><span class="toc-number">1.2.4.</span> <span class="toc-text">结论: 解决问题方法的效率还跟算法的巧妙程度有关.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-抽象数据类型"><span class="toc-number">1.3.</span> <span class="toc-text">1.1.4 抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#所以到底什么是数据结构"><span class="toc-number">1.3.1.</span> <span class="toc-text">所以到底什么是数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象数据类型-Abstract-Data-Type"><span class="toc-number">1.3.2.</span> <span class="toc-text">抽象数据类型(Abstract Data Type)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-只描述数据对象集和相关操作集-quot-是什么-quot-并不涉及-quot-如何做到-quot-的问题"><span class="toc-number">1.3.3.</span> <span class="toc-text">总结:只描述数据对象集和相关操作集&quot;**是什么**&quot;,并不涉及&quot;**如何做到**&quot;的问题.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tips-数据对象集和操作级在C语言里是独立处理的-而在面向对象语言里往往封装在一个类里"><span class="toc-number">1.3.4.</span> <span class="toc-text">tips: 数据对象集和操作级在C语言里是独立处理的.而在面向对象语言里往往封装在一个类里.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象数据类型举例"><span class="toc-number">1.3.5.</span> <span class="toc-text">抽象数据类型举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-什么是算法"><span class="toc-number">2.</span> <span class="toc-text">1.2 什么是算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1"><span class="toc-number">2.1.</span> <span class="toc-text">1.2.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#描述不依赖于任何一种计算机语言和具体的实现手段-伪代码举例"><span class="toc-number">2.1.1.</span> <span class="toc-text">描述不依赖于任何一种计算机语言和具体的实现手段 伪代码举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-什么是好的算法"><span class="toc-number">2.2.</span> <span class="toc-text">1.2.2 什么是好的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-复杂度的渐进表示法"><span class="toc-number">2.3.</span> <span class="toc-text">1.2.3 复杂度的渐进表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析的小窍门"><span class="toc-number">2.3.1.</span> <span class="toc-text">复杂度分析的小窍门</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-应用实例-最大子列和问题"><span class="toc-number">3.</span> <span class="toc-text">1.3 应用实例:最大子列和问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法1"><span class="toc-number">3.1.</span> <span class="toc-text">算法1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法2"><span class="toc-number">3.2.</span> <span class="toc-text">算法2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法3-感觉比较糊-看最后附上的代码吧"><span class="toc-number">3.3.</span> <span class="toc-text">算法3 (感觉比较糊,看最后附上的代码吧 )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法4"><span class="toc-number">3.4.</span> <span class="toc-text">算法4</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第一讲 基本概念<br><a id="more"></a></p>
<h2 id="1-1-什么是数据结构"><a href="#1-1-什么是数据结构" class="headerlink" title="1.1 什么是数据结构"></a>1.1 什么是数据结构</h2><blockquote>
<p>数据结构(Data Structure)是计算机中存储,组织数据的方式. 通常情况下,精心选择的<strong>数据结构</strong>可以带来最优效率的<strong>算法</strong>.</p>
<p>—维基百科</p>
</blockquote>
<h3 id="1-1-1-图书存放方式的例子说明"><a href="#1-1-1-图书存放方式的例子说明" class="headerlink" title="1.1.1 图书存放方式的例子说明:"></a>1.1.1 图书存放方式的例子说明:</h3><p>####<code>结论: 解决问题方法的效率跟数据的组织方式有关.</code></p>
<h3 id="1-1-2-关于空间的使用"><a href="#1-1-2-关于空间的使用" class="headerlink" title="1.1.2 关于空间的使用"></a>1.1.2 关于空间的使用</h3><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_211127.jpg" alt="2017-09-22_211127"></p>
<h4 id="结果-N取大值时递归由于占用过多资源直接报错-所以要谨慎使用递归"><a href="#结果-N取大值时递归由于占用过多资源直接报错-所以要谨慎使用递归" class="headerlink" title="结果: N取大值时递归由于占用过多资源直接报错.所以要谨慎使用递归."></a><code>结果: N取大值时递归由于占用过多资源直接报错.所以要谨慎使用递归.</code></h4><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_211805.jpg" alt="2017-09-22_211805"></p>
<h4 id="结果-第一种不如第二种先采用结合律有内往外算的方法"><a href="#结果-第一种不如第二种先采用结合律有内往外算的方法" class="headerlink" title="结果: 第一种不如第二种先采用结合律有内往外算的方法."></a><code>结果: 第一种不如第二种先采用结合律有内往外算的方法.</code></h4><h4 id="Tips-C语言clock-函数计算运行时钟打点示例"><a href="#Tips-C语言clock-函数计算运行时钟打点示例" class="headerlink" title="Tips: C语言clock()函数计算运行时钟打点示例"></a>Tips: C语言clock()函数计算运行时钟打点示例</h4><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_212219.jpg" alt="2017-09-22_212219"></p>
<h4 id="结论-解决问题方法的效率还跟算法的巧妙程度有关"><a href="#结论-解决问题方法的效率还跟算法的巧妙程度有关" class="headerlink" title="结论: 解决问题方法的效率还跟算法的巧妙程度有关."></a><code>结论: 解决问题方法的效率还跟算法的巧妙程度有关.</code></h4><h3 id="1-1-4-抽象数据类型"><a href="#1-1-4-抽象数据类型" class="headerlink" title="1.1.4 抽象数据类型"></a>1.1.4 抽象数据类型</h3><h4 id="所以到底什么是数据结构"><a href="#所以到底什么是数据结构" class="headerlink" title="所以到底什么是数据结构"></a>所以到底什么是数据结构</h4><ul>
<li><p><strong>数据对象</strong>在计算机中的组织方式</p>
<ul>
<li><p>逻辑结构 </p>
<p>线性结构[^一对一]和树形结构[^一对多]和图的结构[^多对多]</p>
</li>
<li><p>物理存储结构</p>
<p>用<code>抽象数据类型(Abstract Data Type)</code>来描述</p>
</li>
</ul>
</li>
<li><p>数据对象必定与一系列加在其上的<strong>操作</strong>相关联</p>
</li>
<li><p>完成这些操作所用的方法就是<strong>算法</strong></p>
</li>
</ul>
<h4 id="抽象数据类型-Abstract-Data-Type"><a href="#抽象数据类型-Abstract-Data-Type" class="headerlink" title="抽象数据类型(Abstract Data Type)"></a>抽象数据类型(Abstract Data Type)</h4><ul>
<li><p>数据类型</p>
<ul>
<li>数据对象集</li>
<li>数据集合相关联的操作集</li>
</ul>
</li>
<li>抽象: 描述数据类型的方法不依赖于具体实现<ul>
<li>与存放数据的机器无关</li>
<li>与数据存储的物理结构无关</li>
<li>与实现操作的算法和编程语言均无关<h4 id="总结-只描述数据对象集和相关操作集-quot-是什么-quot-并不涉及-quot-如何做到-quot-的问题"><a href="#总结-只描述数据对象集和相关操作集-quot-是什么-quot-并不涉及-quot-如何做到-quot-的问题" class="headerlink" title="总结:只描述数据对象集和相关操作集&quot;**是什么**&quot;,并不涉及&quot;**如何做到**&quot;的问题."></a><code>总结:只描述数据对象集和相关操作集&quot;**是什么**&quot;,并不涉及&quot;**如何做到**&quot;的问题.</code></h4></li>
</ul>
</li>
</ul>
<h4 id="tips-数据对象集和操作级在C语言里是独立处理的-而在面向对象语言里往往封装在一个类里"><a href="#tips-数据对象集和操作级在C语言里是独立处理的-而在面向对象语言里往往封装在一个类里" class="headerlink" title="tips: 数据对象集和操作级在C语言里是独立处理的.而在面向对象语言里往往封装在一个类里."></a><code>tips: 数据对象集和操作级在C语言里是独立处理的.而在面向对象语言里往往封装在一个类里.</code></h4><h4 id="抽象数据类型举例"><a href="#抽象数据类型举例" class="headerlink" title="抽象数据类型举例"></a>抽象数据类型举例</h4><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_220820.jpg" alt="2017-09-22_220820"></p>
<hr>
<h2 id="1-2-什么是算法"><a href="#1-2-什么是算法" class="headerlink" title="1.2 什么是算法"></a>1.2 什么是算法</h2><h3 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2.1"></a>1.2.1</h3><p>定义:</p>
<ul>
<li>算法(Algorithm)<ul>
<li>一个有限的指令集</li>
<li>接受一些是输入(可选)</li>
<li>产生输出</li>
<li>一定在<strong>有限</strong>步骤后终止</li>
<li>每一条指令必须<ul>
<li>有充分明确的目标,无歧义</li>
<li>计算机处理能力之内</li>
<li>描述不依赖于任何一种计算机语言和具体的实现手段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="描述不依赖于任何一种计算机语言和具体的实现手段-伪代码举例"><a href="#描述不依赖于任何一种计算机语言和具体的实现手段-伪代码举例" class="headerlink" title="描述不依赖于任何一种计算机语言和具体的实现手段 伪代码举例"></a>描述不依赖于任何一种计算机语言和具体的实现手段 伪代码举例</h4><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_222027.jpg" alt="2017-09-22_222027"></p>
<h3 id="1-2-2-什么是好的算法"><a href="#1-2-2-什么是好的算法" class="headerlink" title="1.2.2 什么是好的算法"></a>1.2.2 什么是好的算法</h3><ul>
<li><p>空间复杂度 S(n)</p>
<p>根据算法写成的程序在执行时<strong>占用存储单元的长度</strong>。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</p>
</li>
<li><p>时间复杂度 T(n)</p>
<p>根据算法写成的程序在执行时<strong>耗费时间的长度</strong>。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。</p>
</li>
</ul>
<p>回顾 前面1.1.2 :</p>
<p>​    递归和循环两种计算printN方法的空间复杂度区别;</p>
<p>​    计算多项式两种方法的时间复杂度区别(由于计算机计算加减法远快于乘除法,所以这里采用计算做了多少次乘法就可以衡量时间复杂度).</p>
<p>在分析一般算法的效率时,我们一般关注下面两种复杂度</p>
<ul>
<li>最坏情况复杂度 $$T_{worst}$$ </li>
<li>平均复杂度 $$T_{avg}(n)$$ </li>
</ul>
<p>$T_{avg}(n)$ &lt;= $T_{worst}(n)$</p>
<h3 id="1-2-3-复杂度的渐进表示法"><a href="#1-2-3-复杂度的渐进表示法" class="headerlink" title="1.2.3 复杂度的渐进表示法"></a>1.2.3 复杂度的渐进表示法</h3><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_225545.jpg" alt="2017-09-22_225545"></p>
<ul>
<li><p>T(n)=O(<em>f(n)</em>) 表示<em>f(n)</em>是T(n)的某种上界</p>
</li>
<li><p>T(n)=G(<em>f(n)</em>) 表示<em>f(n)</em>是T(n)的某种下界</p>
</li>
<li><p>T(n)=Θ(<em>f(n)</em>) 表示<em>f(n)</em>既是上界又是下界,<em>f(n)</em>与T(n)几乎是等价的</p>
<p><code>Theta(大写Θ,小写θ)</code></p>
</li>
</ul>
<h4 id="复杂度分析的小窍门"><a href="#复杂度分析的小窍门" class="headerlink" title="复杂度分析的小窍门"></a>复杂度分析的小窍门</h4><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_232827.jpg" alt="2017-09-22_232827"></p>
<hr>
<h2 id="1-3-应用实例-最大子列和问题"><a href="#1-3-应用实例-最大子列和问题" class="headerlink" title="1.3 应用实例:最大子列和问题"></a>1.3 应用实例:最大子列和问题</h2><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_233548.jpg" alt="2017-09-22_233548"></p>
<p>分析可以发现其实没必要单独做k循环,因为j循环里后一项都是前面一项加上A[j]</p>
<h3 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h3><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_233600.jpg" alt="2017-09-22_233600"></p>
<p>一个小技巧:当发现算法复杂度是$$O(N^2)$$ 会想着能不能转换为O(n* log n)</p>
<h3 id="算法3-感觉比较糊-看最后附上的代码吧"><a href="#算法3-感觉比较糊-看最后附上的代码吧" class="headerlink" title="算法3 (感觉比较糊,看最后附上的代码吧 )"></a>算法3 (感觉比较糊,看最后附上的代码吧 )</h3><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_233612.jpg" alt="2017-09-22_233612"></p>
<p>思路:<strong>多次</strong>一分为二,分别找出左侧的最大子列和与右侧的最大子列和以及跨越边界的最大子列和,比较得出最大的值(图里最大子列和是11). </p>
<p>注意理解: 跨越边界子列和是指一条边界(不管第几级的边界)两边的范围内最大的子列和,边界必须包含在内.类似一个包含此级边界但不超过上一级边界的滑动窗口—这个比较难理解.</p>
<p>分析复杂度: </p>
<p>左侧和右侧的最大子列复杂度都是T(N/2)这个无疑问.</p>
<p>跨越中间边界线子列的复杂度是因为它是分别计算最大一级边界线左边的最大值和右边的最大值,然后加起来,相当于N个值每个值都只扫了一遍.复杂度为N.</p>
<p>(往一边扫描方法:直接不断由边界线向左扫描累加,每次加完判断子列和是否大于暂存的局部最大子列,注意若子列和的最终返回值为负数时返回值置零,避免影响下一步上一级边界线两边的累加)</p>
<h3 id="算法4"><a href="#算法4" class="headerlink" title="算法4"></a>算法4</h3><p><img src="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/2017-09-22_233623.jpg" alt="2017-09-22_233623"></p>
<p>从左往右处理,只要值<strong>为负数就归零</strong>在重新继续算,不为负数时才计算累加后的值比原来的最大值大还是小.之所以叫做在线处理,是因为当它扫描到从左往右的第N个数时,它一定是已扫描部分的最大子列和,即局部的真解.</p>
<p>第三种算法比较难懂,附上老师给的代码来理解:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max3</span><span class="params">( <span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 返回3个整数中的最大值 */</span></span><br><span class="line">    <span class="keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DivideAndConquer</span><span class="params">( <span class="keyword">int</span> List[], <span class="keyword">int</span> left, <span class="keyword">int</span> right )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 分治法求List[left]到List[right]的最大子列和 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxLeftSum, MaxRightSum; <span class="comment">/* 存放左右子问题的解 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="comment">/*存放跨分界线的结果*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> LeftBorderSum, RightBorderSum;</span><br><span class="line">    <span class="keyword">int</span> center, i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( left == right )  &#123; <span class="comment">/* 递归的终止条件，子列只有1个数字 */</span></span><br><span class="line">        <span class="keyword">if</span>( List[left] &gt; <span class="number">0</span> )  <span class="keyword">return</span> List[left];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面是"分"的过程 */</span></span><br><span class="line">    center = ( left + right ) / <span class="number">2</span>; <span class="comment">/* 找到中分点 */</span></span><br><span class="line">    <span class="comment">/* 递归求得两边子列的最大和 */</span></span><br><span class="line">    MaxLeftSum = DivideAndConquer( List, left, center );</span><br><span class="line">    MaxRightSum = DivideAndConquer( List, center+<span class="number">1</span>, right );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面求跨分界线的最大子列和 */</span></span><br><span class="line">    MaxLeftBorderSum = <span class="number">0</span>; LeftBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center; i&gt;=left; i-- ) &#123; <span class="comment">/* 从中线向左扫描 */</span></span><br><span class="line">        LeftBorderSum += List[i];</span><br><span class="line">        <span class="keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )</span><br><span class="line">            MaxLeftBorderSum = LeftBorderSum;</span><br><span class="line">    &#125; <span class="comment">/* 左边扫描结束 */</span></span><br><span class="line"> </span><br><span class="line">    MaxRightBorderSum = <span class="number">0</span>; RightBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center+<span class="number">1</span>; i&lt;=right; i++ ) &#123; <span class="comment">/* 从中线向右扫描 */</span></span><br><span class="line">        RightBorderSum += List[i];</span><br><span class="line">        <span class="keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )</span><br><span class="line">            MaxRightBorderSum = RightBorderSum;</span><br><span class="line">    &#125; <span class="comment">/* 右边扫描结束 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面返回"治"的结果 */</span></span><br><span class="line">    <span class="keyword">return</span> Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum3</span><span class="params">( <span class="keyword">int</span> List[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 保持与前2种算法相同的函数接口 */</span></span><br><span class="line">    <span class="keyword">return</span> DivideAndConquer( List, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/数据结构/">数据结构</a></div><div class="post-nav"><a class="pre" href="/2017/09/27/浙大_数据结构_第二讲_线性结构_笔记/">浙大_数据结构_第二讲_线性结构_笔记</a><a class="next" href="/2017/03/25/Hexo博客搭建过程备忘/">Hexo博客搭建过程备忘</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c1a5c3e9da362701eef8',
  clientSecret: '9151237934be60c72d23fcd7efb5ee2798bf2b5a',
  repo: 'sixtar.github.io',
  owner: 'sixtar',
  admin: ['sixtar'],
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://sixtar.org"/></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://sixtar.org"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/慕课/" style="font-size: 15px;">慕课</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/12/【慕课笔记】Spring-Data-Jpa基本使用/">【慕课笔记】Spring Data Jpa基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/01/【慕课笔记】第一个docker化的java应用/">【慕课笔记】第一个Docker化的java应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/浙大_数据结构_第二讲_线性结构_笔记/">浙大_数据结构_第二讲_线性结构_笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/23/浙大_数据结构_第一讲_基本概念_笔记/">浙大_数据结构_第一讲_基本概念_笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/25/Hexo博客搭建过程备忘/">Hexo博客搭建过程备忘</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.v2ex.com/" title="V2EX" target="_blank">V2EX</a><ul></ul><a href="http://www.zhihu.com/" title="全球最大的中文装B社区" target="_blank">全球最大的中文装B社区</a><ul></ul><a href="http://www.baidu.com/" title="程序员灵感的来源" target="_blank">程序员灵感的来源</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Sixtar.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>